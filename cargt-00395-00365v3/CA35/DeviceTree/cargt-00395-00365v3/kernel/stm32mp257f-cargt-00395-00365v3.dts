// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
/*
 * Copyright (C) 2025, STMicroelectronics - All Rights Reserved
 * Author: STM32CubeMX code generation for STMicroelectronics.
 */

/* For more information on Device Tree configuration, please refer to
 * https://wiki.st.com/stm32mpu/wiki/Category:Device_tree_configuration
 */

/dts-v1/;

#include <dt-bindings/pinctrl/stm32-pinfunc.h>
#include "stm32mp257.dtsi"
#include "stm32mp25xf.dtsi"
#include "stm32mp257f-cargt-00395-00365v3-resmem.dtsi"
#include "stm32mp25xxak-pinctrl.dtsi"

/* USER CODE BEGIN includes */
#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/input/input.h>
#include <dt-bindings/leds/common.h>
#include <dt-bindings/rtc/rtc-stm32.h>
#include "dt-bindings/usb/pd.h"
#include <dt-bindings/regulator/st,stm32mp25-regulator.h>
/* USER CODE END includes */

/ {
	model = "STMicroelectronics custom STM32CubeMX board - openstlinux-6.6-yocto-scarthgap-mpu-v25.06.11";
	compatible = "st,stm32mp257f-cargt-00395-00365v3", "st,stm32mp257";

	memory@80000000 {
		device_type = "memory";
		reg = <0x0 0x80000000 0x0 0x80000000>;

		/* USER CODE BEGIN memory */
		/* USER CODE END memory */
	};

	/* USER CODE BEGIN root */
	aliases {
		serial0 = &usart2;
		serial1 = &usart3;
		serial2 = &lpuart1;
		ethernet0 = &eth1;
		ethernet1 = &eth2;
	};

	chosen {
		stdout-path = "serial0:115200n8";
		#address-cells = <2>;
		#size-cells = <2>;
		ranges;

		framebuffer {
			compatible = "simple-framebuffer";
			clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>,
				 <&rcc CK_BUS_LVDS>, <&rcc CK_KER_LVDSPHY>;
			status = "disabled";
		};
	};

	imx335_2v9: imx335-2v9 {
		compatible = "regulator-fixed";
		regulator-name = "imx335-avdd";
		regulator-min-microvolt = <2900000>;
		regulator-max-microvolt = <2900000>;
		regulator-always-on;
	};

	imx335_1v8: imx335-1v8 {
		compatible = "regulator-fixed";
		regulator-name = "imx335-ovdd";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		regulator-always-on;
	};

	imx335_1v2: imx335-1v2 {
		compatible = "regulator-fixed";
		regulator-name = "imx335-dvdd";
		regulator-min-microvolt = <1200000>;
		regulator-max-microvolt = <1200000>;
		regulator-always-on;
	};

	usd_pwron: usd-pwron {
		compatible = "regulator-fixed";
		regulator-name = "usd-pwron";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		gpio = <&gpiod 2 GPIO_ACTIVE_HIGH>;
		enable-active-high;
	};

	reg_sdmmc3_vmmc: regulator-sdmmc3 {
		compatible = "regulator-fixed";
		regulator-name = "WLAN_EN";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		gpio = <&gpiob 1 GPIO_ACTIVE_HIGH>;
		startup-delay-us = <20000>;
		enable-active-high;
	};

	/* USER CODE END root */

	clocks{

		/* USER CODE BEGIN clocks */
		clk_ext_camera: clk-ext-camera {
			#clock-cells = <0>;
			compatible = "fixed-clock";
			clock-frequency = <24000000>;
		};

		clk_ext_cec: clk-ext-cec {
			#clock-cells = <0>;
			compatible = "fixed-clock";
			clock-frequency = <24000000>;
		};		
		/* USER CODE END clocks */
	};

}; /*root*/

&pinctrl {

	eth1_mdio_pins_mx: eth1_mdio_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('F', 0, AF10)>; /* ETH1_MDC */
			bias-disable;
			drive-push-pull;
			slew-rate = <2>;
			st,io-clk-edge = <0>;
			st,io-retime = <0>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('F', 2, AF10)>; /* ETH1_MDIO */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
			st,io-clk-edge = <0>;
			st,io-retime = <0>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
	};

	eth1_mdio_sleep_pins_mx: eth1_mdio_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('F', 0, ANALOG)>, /* ETH1_MDC */
					 <STM32_PINMUX('F', 2, ANALOG)>; /* ETH1_MDIO */
		};
	};

	eth1_rgmii_pins_mx: eth1_rgmii_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('A', 11, AF10)>, /* ETH1_RGMII_RX_CTL */
					 <STM32_PINMUX('C', 2, AF10)>, /* ETH1_RGMII_RXD1 */
					 <STM32_PINMUX('F', 1, AF10)>, /* ETH1_RGMII_RXD0 */
					 <STM32_PINMUX('H', 12, AF10)>, /* ETH1_RGMII_RXD2 */
					 <STM32_PINMUX('H', 13, AF10)>; /* ETH1_RGMII_RXD3 */
			bias-disable;
			drive-push-pull;
			st,io-clk-edge = <1>;
			st,io-retime = <1>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('A', 13, AF10)>, /* ETH1_RGMII_TX_CTL */
					 <STM32_PINMUX('A', 15, AF10)>, /* ETH1_RGMII_TXD0 */
					 <STM32_PINMUX('C', 1, AF10)>, /* ETH1_RGMII_TXD1 */
					 <STM32_PINMUX('H', 10, AF10)>, /* ETH1_RGMII_TXD2 */
					 <STM32_PINMUX('H', 11, AF10)>; /* ETH1_RGMII_TXD3 */
			bias-disable;
			drive-push-pull;
			slew-rate = <2>;
			st,io-clk-edge = <1>;
			st,io-retime = <1>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
		pins3 {
			pinmux = <STM32_PINMUX('A', 14, AF10)>; /* ETH1_RGMII_RX_CLK */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
			st,io-clk-edge = <0>;
			st,io-retime = <0>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
		pins4 {
			pinmux = <STM32_PINMUX('C', 0, AF12)>; /* ETH1_RGMII_GTX_CLK */
			bias-disable;
			drive-push-pull;
			slew-rate = <1>;
			st,io-clk-edge = <0>;
			st,io-retime = <0>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
	};

	eth1_rgmii_sleep_pins_mx: eth1_rgmii_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* ETH1_RGMII_RX_CTL */
					 <STM32_PINMUX('A', 13, ANALOG)>, /* ETH1_RGMII_TX_CTL */
					 <STM32_PINMUX('A', 14, ANALOG)>, /* ETH1_RGMII_RX_CLK */
					 <STM32_PINMUX('A', 15, ANALOG)>, /* ETH1_RGMII_TXD0 */
					 <STM32_PINMUX('C', 0, ANALOG)>, /* ETH1_RGMII_GTX_CLK */
					 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH1_RGMII_TXD1 */
					 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH1_RGMII_RXD1 */
					 <STM32_PINMUX('F', 1, ANALOG)>, /* ETH1_RGMII_RXD0 */
					 <STM32_PINMUX('H', 10, ANALOG)>, /* ETH1_RGMII_TXD2 */
					 <STM32_PINMUX('H', 11, ANALOG)>, /* ETH1_RGMII_TXD3 */
					 <STM32_PINMUX('H', 12, ANALOG)>, /* ETH1_RGMII_RXD2 */
					 <STM32_PINMUX('H', 13, ANALOG)>; /* ETH1_RGMII_RXD3 */
		};
	};

	eth2_mdio_pins_mx: eth2_mdio_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('C', 5, AF10)>; /* ETH2_MDIO */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
			st,io-clk-edge = <0>;
			st,io-retime = <0>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('C', 6, AF10)>; /* ETH2_MDC */
			bias-disable;
			drive-push-pull;
			slew-rate = <2>;
			st,io-clk-edge = <0>;
			st,io-retime = <0>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
	};

	eth2_mdio_sleep_pins_mx: eth2_mdio_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('C', 5, ANALOG)>, /* ETH2_MDIO */
					 <STM32_PINMUX('C', 6, ANALOG)>; /* ETH2_MDC */
		};
	};

	eth2_rgmii_pins_mx: eth2_rgmii_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('C', 4, AF10)>, /* ETH2_RGMII_TX_CTL */
					 <STM32_PINMUX('C', 7, AF10)>, /* ETH2_RGMII_TXD0 */
					 <STM32_PINMUX('C', 8, AF10)>, /* ETH2_RGMII_TXD1 */
					 <STM32_PINMUX('C', 9, AF10)>, /* ETH2_RGMII_TXD2 */
					 <STM32_PINMUX('C', 10, AF10)>; /* ETH2_RGMII_TXD3 */
			bias-disable;
			drive-push-pull;
			slew-rate = <2>;
			st,io-clk-edge = <1>;
			st,io-retime = <1>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('C', 3, AF10)>, /* ETH2_RGMII_RX_CTL */
					 <STM32_PINMUX('C', 11, AF10)>, /* ETH2_RGMII_RXD3 */
					 <STM32_PINMUX('C', 12, AF10)>, /* ETH2_RGMII_RXD1 */
					 <STM32_PINMUX('F', 9, AF10)>, /* ETH2_RGMII_RXD2 */
					 <STM32_PINMUX('G', 0, AF10)>; /* ETH2_RGMII_RXD0 */
			bias-disable;
			drive-push-pull;
			st,io-clk-edge = <1>;
			st,io-retime = <1>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
		pins3 {
			pinmux = <STM32_PINMUX('F', 6, AF10)>; /* ETH2_RGMII_RX_CLK */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
			st,io-clk-edge = <0>;
			st,io-retime = <0>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
		pins4 {
			pinmux = <STM32_PINMUX('F', 7, AF10)>; /* ETH2_RGMII_GTX_CLK */
			bias-disable;
			drive-push-pull;
			slew-rate = <1>;
			st,io-clk-edge = <0>;
			st,io-retime = <0>;
			st,io-delay-path = <0>;
			st,io-delay = <0>;
		};
	};

	eth2_rgmii_sleep_pins_mx: eth2_rgmii_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('C', 3, ANALOG)>, /* ETH2_RGMII_RX_CTL */
					 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH2_RGMII_TX_CTL */
					 <STM32_PINMUX('C', 7, ANALOG)>, /* ETH2_RGMII_TXD0 */
					 <STM32_PINMUX('C', 8, ANALOG)>, /* ETH2_RGMII_TXD1 */
					 <STM32_PINMUX('C', 9, ANALOG)>, /* ETH2_RGMII_TXD2 */
					 <STM32_PINMUX('C', 10, ANALOG)>, /* ETH2_RGMII_TXD3 */
					 <STM32_PINMUX('C', 11, ANALOG)>, /* ETH2_RGMII_RXD3 */
					 <STM32_PINMUX('C', 12, ANALOG)>, /* ETH2_RGMII_RXD1 */
					 <STM32_PINMUX('F', 6, ANALOG)>, /* ETH2_RGMII_RX_CLK */
					 <STM32_PINMUX('F', 7, ANALOG)>, /* ETH2_RGMII_GTX_CLK */
					 <STM32_PINMUX('F', 9, ANALOG)>, /* ETH2_RGMII_RXD2 */
					 <STM32_PINMUX('G', 0, ANALOG)>; /* ETH2_RGMII_RXD0 */
		};
	};

	i2c1_pins_mx: i2c1_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('G', 13, AF9)>, /* I2C1_SCL */
					 <STM32_PINMUX('I', 1, AF9)>; /* I2C1_SDA */
			bias-disable;
			drive-open-drain;
			slew-rate = <0>;
		};
	};

	i2c1_sleep_pins_mx: i2c1_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* I2C1_SCL */
					 <STM32_PINMUX('I', 1, ANALOG)>; /* I2C1_SDA */
		};
	};

	i2c2_pins_mx: i2c2_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('B', 4, AF9)>, /* I2C2_SDA */
					 <STM32_PINMUX('B', 5, AF9)>; /* I2C2_SCL */
			bias-disable;
			drive-open-drain;
			slew-rate = <0>;
		};
	};

	i2c2_sleep_pins_mx: i2c2_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('B', 4, ANALOG)>, /* I2C2_SDA */
					 <STM32_PINMUX('B', 5, ANALOG)>; /* I2C2_SCL */
		};
	};

	i2c4_pins_mx: i2c4_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('D', 10, AF6)>, /* I2C4_SDA */
					 <STM32_PINMUX('D', 11, AF6)>; /* I2C4_SCL */
			bias-disable;
			drive-open-drain;
			slew-rate = <0>;
		};
	};

	i2c4_sleep_pins_mx: i2c4_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('D', 10, ANALOG)>, /* I2C4_SDA */
					 <STM32_PINMUX('D', 11, ANALOG)>; /* I2C4_SCL */
		};
	};

	i2c6_pins_mx: i2c6_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('G', 5, AF9)>, /* I2C6_SDA */
					 <STM32_PINMUX('G', 6, AF9)>; /* I2C6_SCL */
			bias-disable;
			drive-open-drain;
			slew-rate = <0>;
		};
	};

	i2c6_sleep_pins_mx: i2c6_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* I2C6_SDA */
					 <STM32_PINMUX('G', 6, ANALOG)>; /* I2C6_SCL */
		};
	};

	sdmmc1_pins_mx: sdmmc1_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
					 <STM32_PINMUX('E', 1, AF10)>, /* SDMMC1_D3 */
					 <STM32_PINMUX('E', 2, AF10)>, /* SDMMC1_CMD */
					 <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
					 <STM32_PINMUX('E', 5, AF10)>; /* SDMMC1_D1 */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <1>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <2>;
		};
	};

	sdmmc1_opendrain_pins_mx: sdmmc1_opendrain_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
					 <STM32_PINMUX('E', 1, AF10)>, /* SDMMC1_D3 */
					 <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
					 <STM32_PINMUX('E', 5, AF10)>; /* SDMMC1_D1 */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <1>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
			bias-pull-up;
			drive-open-drain;
			slew-rate = <1>;
		};
		pins3 {
			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <2>;
		};
	};

	sdmmc1_sleep_pins_mx: sdmmc1_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('E', 0, ANALOG)>, /* SDMMC1_D2 */
					 <STM32_PINMUX('E', 1, ANALOG)>, /* SDMMC1_D3 */
					 <STM32_PINMUX('E', 2, ANALOG)>, /* SDMMC1_CMD */
					 <STM32_PINMUX('E', 3, ANALOG)>, /* SDMMC1_CK */
					 <STM32_PINMUX('E', 4, ANALOG)>, /* SDMMC1_D0 */
					 <STM32_PINMUX('E', 5, ANALOG)>; /* SDMMC1_D1 */
		};
	};

	sdmmc2_pins_mx: sdmmc2_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('E', 6, AF12)>, /* SDMMC2_D6 */
					 <STM32_PINMUX('E', 7, AF12)>, /* SDMMC2_D7 */
					 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
					 <STM32_PINMUX('E', 9, AF12)>, /* SDMMC2_D5 */
					 <STM32_PINMUX('E', 10, AF12)>, /* SDMMC2_D4 */
					 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
					 <STM32_PINMUX('E', 12, AF12)>, /* SDMMC2_D3 */
					 <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
					 <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <1>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <2>;
		};
	};

	sdmmc2_opendrain_pins_mx: sdmmc2_opendrain_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('E', 6, AF12)>, /* SDMMC2_D6 */
					 <STM32_PINMUX('E', 7, AF12)>, /* SDMMC2_D7 */
					 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
					 <STM32_PINMUX('E', 9, AF12)>, /* SDMMC2_D5 */
					 <STM32_PINMUX('E', 10, AF12)>, /* SDMMC2_D4 */
					 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
					 <STM32_PINMUX('E', 12, AF12)>, /* SDMMC2_D3 */
					 <STM32_PINMUX('E', 13, AF12)>; /* SDMMC2_D0 */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <1>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <2>;
		};
		pins3 {
			pinmux = <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
			bias-pull-up;
			drive-open-drain;
			slew-rate = <1>;
		};
	};

	sdmmc2_sleep_pins_mx: sdmmc2_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('E', 6, ANALOG)>, /* SDMMC2_D6 */
					 <STM32_PINMUX('E', 7, ANALOG)>, /* SDMMC2_D7 */
					 <STM32_PINMUX('E', 8, ANALOG)>, /* SDMMC2_D2 */
					 <STM32_PINMUX('E', 9, ANALOG)>, /* SDMMC2_D5 */
					 <STM32_PINMUX('E', 10, ANALOG)>, /* SDMMC2_D4 */
					 <STM32_PINMUX('E', 11, ANALOG)>, /* SDMMC2_D1 */
					 <STM32_PINMUX('E', 12, ANALOG)>, /* SDMMC2_D3 */
					 <STM32_PINMUX('E', 13, ANALOG)>, /* SDMMC2_D0 */
					 <STM32_PINMUX('E', 14, ANALOG)>, /* SDMMC2_CK */
					 <STM32_PINMUX('E', 15, ANALOG)>; /* SDMMC2_CMD */
		};
	};

	sdmmc3_pins_mx: sdmmc3_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
					 <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
					 <STM32_PINMUX('D', 12, AF10)>, /* SDMMC3_CMD */
					 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
					 <STM32_PINMUX('I', 11, AF10)>; /* SDMMC3_D3 */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <0>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <1>;
		};
	};

	sdmmc3_opendrain_pins_mx: sdmmc3_opendrain_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
					 <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
					 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
					 <STM32_PINMUX('I', 11, AF10)>; /* SDMMC3_D3 */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <0>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <1>;
		};
		pins3 {
			pinmux = <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
			bias-pull-up;
			drive-open-drain;
			slew-rate = <0>;
		};
	};

	sdmmc3_sleep_pins_mx: sdmmc3_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('B', 12, ANALOG)>, /* SDMMC3_D2 */
					 <STM32_PINMUX('B', 13, ANALOG)>, /* SDMMC3_CK */
					 <STM32_PINMUX('B', 14, ANALOG)>, /* SDMMC3_D0 */
					 <STM32_PINMUX('D', 12, ANALOG)>, /* SDMMC3_CMD */
					 <STM32_PINMUX('D', 13, ANALOG)>, /* SDMMC3_D1 */
					 <STM32_PINMUX('I', 11, ANALOG)>; /* SDMMC3_D3 */
		};
	};

	spi4_pins_mx: spi4_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('D', 4, AF1)>, /* SPI4_MISO */
					 <STM32_PINMUX('D', 6, AF1)>, /* SPI4_MOSI */
					 <STM32_PINMUX('D', 7, AF1)>; /* SPI4_SCK */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
	};

	spi4_sleep_pins_mx: spi4_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('D', 4, ANALOG)>, /* SPI4_MISO */
					 <STM32_PINMUX('D', 6, ANALOG)>, /* SPI4_MOSI */
					 <STM32_PINMUX('D', 7, ANALOG)>; /* SPI4_SCK */
		};
	};

	tim10_pwm_pins_mx: tim10_pwm_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('B', 9, AF9)>; /* TIM10_CH1 */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
	};

	tim10_pwm_sleep_pins_mx: tim10_pwm_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('B', 9, ANALOG)>; /* TIM10_CH1 */
		};
	};

	uart5_pins_mx: uart5_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('G', 10, AF5)>; /* UART5_RX */
			bias-disable;
			drive-push-pull;
		};
		pins2 {
			pinmux = <STM32_PINMUX('G', 9, AF5)>; /* UART5_TX */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
	};

	uart5_idle_pins_mx: uart5_idle_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('G', 10, AF5)>; /* UART5_RX */
			bias-disable;
			drive-push-pull;
		};
		pins2 {
			pinmux = <STM32_PINMUX('G', 9, ANALOG)>; /* UART5_TX */
		};
	};

	uart5_sleep_pins_mx: uart5_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('G', 9, ANALOG)>, /* UART5_TX */
					 <STM32_PINMUX('G', 10, ANALOG)>; /* UART5_RX */
		};
	};

	uart7_pins_mx: uart7_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('D', 0, AF6)>; /* UART7_RX */
			bias-disable;
			drive-push-pull;
		};
		pins2 {
			pinmux = <STM32_PINMUX('D', 3, AF6)>; /* UART7_TX */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
	};

	uart7_idle_pins_mx: uart7_idle_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('D', 0, AF6)>; /* UART7_RX */
			bias-disable;
			drive-push-pull;
		};
		pins2 {
			pinmux = <STM32_PINMUX('D', 3, ANALOG)>; /* UART7_TX */
		};
	};

	uart7_sleep_pins_mx: uart7_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('D', 0, ANALOG)>, /* UART7_RX */
					 <STM32_PINMUX('D', 3, ANALOG)>; /* UART7_TX */
		};
	};

	usart2_pins_mx: usart2_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('A', 4, AF6)>; /* USART2_TX */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
			bias-disable;
			drive-push-pull;
		};
	};

	usart2_idle_pins_mx: usart2_idle_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('A', 4, ANALOG)>; /* USART2_TX */
		};
		pins2 {
			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
			bias-disable;
			drive-push-pull;
		};
	};

	usart2_sleep_pins_mx: usart2_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('A', 4, ANALOG)>, /* USART2_TX */
					 <STM32_PINMUX('A', 8, ANALOG)>; /* USART2_RX */
		};
	};

	usart3_pins_mx: usart3_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('F', 13, AF6)>, /* USART3_CTS */
					 <STM32_PINMUX('I', 7, AF6)>; /* USART3_RX */
			bias-disable;
			drive-push-pull;
		};
		pins2 {
			pinmux = <STM32_PINMUX('F', 14, AF6)>, /* USART3_RTS */
					 <STM32_PINMUX('I', 6, AF6)>; /* USART3_TX */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
	};

	usart3_idle_pins_mx: usart3_idle_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART3_CTS */
					 <STM32_PINMUX('I', 6, ANALOG)>; /* USART3_TX */
		};
		pins2 {
			pinmux = <STM32_PINMUX('F', 14, AF6)>; /* USART3_RTS */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
		pins3 {
			pinmux = <STM32_PINMUX('I', 7, AF6)>; /* USART3_RX */
			bias-disable;
			drive-push-pull;
		};
	};

	usart3_sleep_pins_mx: usart3_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART3_CTS */
					 <STM32_PINMUX('F', 14, ANALOG)>, /* USART3_RTS */
					 <STM32_PINMUX('I', 6, ANALOG)>, /* USART3_TX */
					 <STM32_PINMUX('I', 7, ANALOG)>; /* USART3_RX */
		};
	};

	/* USER CODE BEGIN pinctrl */

	
	ptn5110_51_pins: ptn5110_51_pins-0 {
		pins {															
			pinmux = <STM32_PINMUX('G', 15, GPIO)>; /* USB_A_nALERT_1V8 */		
			bias-pull-up;
		};																
	};
	
	ptn5110_52_pins: ptn5110_52_pins-0 {
		pins {															
			pinmux = <STM32_PINMUX('B', 11, GPIO)>; /* USB_C_nALERT_1V8 */		
			bias-pull-up;
		};																
	};
	
	pinctrl_lvds_touchscreen: pinctrl_lvds_touchscreen-0 {
		pins {															
			pinmux = <STM32_PINMUX('B', 6, GPIO)>; /* LVDSCT_nINT */		
		};																
	};						

	pinctrl_dsi_touchscreen: pinctrl_dsi_touchscreen-0 {
		pins {															
			pinmux = <STM32_PINMUX('B', 3, GPIO)>; /* DSICT_nINT */		
		};																
	};	

	pinctrl_rtc: pinctrl_rtc-0 {
		pins {															
			pinmux = <STM32_PINMUX('B', 10, GPIO)>; /* RTC_nINT */		
			bias-pull-up;
		};	
	};

	/* USER CODE END pinctrl */
};

&pinctrl_z {

	lpuart1_pins_z_mx: lpuart1_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('Z', 0, AF6)>, /* LPUART1_TX */
					 <STM32_PINMUX('Z', 1, AF6)>, /* LPUART1_RX */
					 <STM32_PINMUX('Z', 2, AF6)>, /* LPUART1_RTS */
					 <STM32_PINMUX('Z', 3, AF6)>; /* LPUART1_CTS */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
	};

	lpuart1_sleep_pins_z_mx: lpuart1_sleep_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('Z', 0, ANALOG)>, /* LPUART1_TX */
					 <STM32_PINMUX('Z', 1, ANALOG)>, /* LPUART1_RX */
					 <STM32_PINMUX('Z', 2, ANALOG)>, /* LPUART1_RTS */
					 <STM32_PINMUX('Z', 3, ANALOG)>; /* LPUART1_CTS */
		};
	};

	/* USER CODE BEGIN pinctrl_z */
	/* USER CODE END pinctrl_z */
};

&combophy {
	status = "okay";

	/* USER CODE BEGIN combophy */
	clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>;
	clock-names = "apb-clk", "ker-clk";
	st,rx_equalizer = <1>;
	/* USER CODE END combophy */
};

&cryp1 {
	status = "okay";

	/* USER CODE BEGIN cryp1 */
	/* USER CODE END cryp1 */
};

&csi {
	status = "okay";

	/* USER CODE BEGIN csi */
	vdd-supply =  <&scmi_vddcore>;
	vdda18-supply = <&scmi_v1v8>;
	ports {
		#address-cells = <1>;
		#size-cells = <0>;
		port@0 {
			reg = <0>;
			csi_sink: endpoint {
				remote-endpoint = <&imx335_ep>;
				data-lanes = <1 2>;
				bus-type = <4>;
			};
		};
		port@1 {
			reg = <1>;
			csi_source: endpoint {
				remote-endpoint = <&dcmipp_0>;
			};
		};
	};
	/* USER CODE END csi */
};

&dcmipp {
	status = "okay";

	/* USER CODE BEGIN dcmipp */
	port {
		dcmipp_0: endpoint {
			remote-endpoint = <&csi_source>;
			bus-type = <4>;
		};
	};	
	/* USER CODE END dcmipp */
};

&dsi {
	status = "okay";

	/* USER CODE BEGIN dsi */
	vdd-supply =  <&scmi_vddcore>;
	vdda18-supply = <&scmi_v1v8>;
	ports {
		#address-cells = <1>;
		#size-cells = <0>;

		port@0 {
			reg = <0>;
			dsi_in: endpoint {
				remote-endpoint = <&ltdc_ep0_out>;
			};
		};
	};
	/* USER CODE END dsi */
};

&eth1 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&eth1_mdio_pins_mx>, <&eth1_rgmii_pins_mx>;
	pinctrl-1 = <&eth1_mdio_sleep_pins_mx>, <&eth1_rgmii_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN eth1 */
	pinctrl-names = "default", "sleep";
	phy-mode = "rgmii-id";
	max-speed = <1000>;
	phy-handle = <&phy1_eth1>;
	st,eth-ptp-from-rcc;
	st,eth-clk-sel;
	snps,ext-systime;

	mdio1 {
		#address-cells = <1>;
		#size-cells = <0>;
		compatible = "snps,dwmac-mdio";
		phy1_eth1: ethernet-phy@0 {
			compatible = "ethernet-phy-id001c.c916";
			reset-gpios =  <&pca9555_20 0 GPIO_ACTIVE_LOW>;
			reset-assert-us = <10000>;
			reset-deassert-us = <80000>;
			realtek,eee-disable;
			reg = <0>;
		};
	};	
	/* USER CODE END eth1 */
};

&eth2 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&eth2_mdio_pins_mx>, <&eth2_rgmii_pins_mx>;
	pinctrl-1 = <&eth2_mdio_sleep_pins_mx>, <&eth2_rgmii_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN eth2 */
	phy-mode = "rgmii-id";
	max-speed = <1000>;
	phy-handle = <&phy1_eth2>;
	st,eth-ptp-from-rcc;
	st,eth-clk-sel;
	snps,ext-systime;

	mdio1 {
		#address-cells = <1>;
		#size-cells = <0>;
		compatible = "snps,dwmac-mdio";
		phy1_eth2: ethernet-phy@1 {
			compatible = "ethernet-phy-id001c.c916";
			reset-gpios =  <&pca9555_20 1 GPIO_ACTIVE_LOW>;
			reset-assert-us = <10000>;
			reset-deassert-us = <80000>;
			realtek,eee-disable;
			reg = <1>;
		};
	};	
	/* USER CODE END eth2 */
};

&gpu {
	status = "okay";

	/* USER CODE BEGIN gpu */
	contiguous-area = <&gpu_reserved>;
	/* USER CODE END gpu */
};

&hpdma {
	status = "okay";

	/* USER CODE BEGIN hpdma */
	memory-region = <&hpdma1_lli>;
	/* USER CODE END hpdma */
};

&hpdma2 {
	status = "okay";

	/* USER CODE BEGIN hpdma2 */
	memory-region = <&hpdma2_lli>;
	/* USER CODE END hpdma2 */
};

&hpdma3 {
	status = "okay";

	/* USER CODE BEGIN hpdma3 */
	memory-region = <&hpdma3_lli>;
	/* USER CODE END hpdma3 */
};

&i2c1 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&i2c1_pins_mx>;
	pinctrl-1 = <&i2c1_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN i2c1 */
	i2c-scl-rising-time-ns = <108>;
	i2c-scl-falling-time-ns = <12>;
	clock-frequency = <400000>;
	status = "okay";
	/* spare dmas for other usage */
	/delete-property/dmas;
	/delete-property/dma-names;

	pca9555_20: pca9555@20 {
		compatible = "nxp,pca9555";
		gpio-controller;
		#gpio-cells = <2>;
		reg = <0x20>;
		gpio-line-names =
			"pca9555_20-0",	"pca9555_20-1",	"pca9555_20-2",	"pca9555_20-3", 	// 0-3
			"pca9555_20-4",	"pca9555_20-5",	"pca9555_20-6",	"pca9555_20-7",		// 4-7
			"pca9555_20-8",	"pca9555_20-9",	"pca9555_20-10","pca9555_20-11", 	// 8-11
			"pca9555_20-12","pca9555_20-13","pca9555_20-14","pca9555_20-15"; 	// 12-15		
	};

	rtc_i2c: rtc@32 {
		compatible ="epson,rx8111";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_rtc>;
		interrupt-parent = <&gpiob>;
        interrupts = <10 GPIO_ACTIVE_LOW>;
		reg = <0x32>;
	};	
	
	eeprom@50 {
		compatible = "atmel,24c02";
		reg = <0x50>;
		pagesize = <16>;		
		status = "okay";
	};

	ptn5110_51: tcpc@51 {
		compatible = "nxp,ptn5110";
		reg = <0x51>;
		pinctrl-0 = <&ptn5110_51_pins>;
		interrupt-parent = <&gpiog>;
		interrupts = <15 IRQ_TYPE_LEVEL_LOW>;
		status = "okay";

		usbc_a_con: connector {
			compatible = "usb-c-connector";
			label = "USB-C(A)";
			power-role = "dual";
			data-role = "dual";
			try-power-role = "sink";
			source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
			sink-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
				     PDO_VAR(5000, 20000, 3000)>;
			op-sink-microwatt = <15000000>;
			self-powered;
			status = "okay";

			port {
				typec_a_ep: endpoint {
					remote-endpoint = <&dwc3_ep>;
				};
			};
		};
	};

	ptn5110_52: tcpc@52 {
		compatible = "nxp,ptn5110";
		reg = <0x52>;
		pinctrl-0 = <&ptn5110_52_pins>;
		interrupt-parent = <&gpiob>;
		interrupts = <11 IRQ_TYPE_LEVEL_LOW>;
		status = "okay";

		usbc_c_con: connector {
			compatible = "usb-c-connector";
			label = "USB-C(C)";
			power-role = "source";
			data-role = "host";
			source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
			self-powered;
			status = "okay";
		};
	};

	imx335: camera@1a {
		compatible = "sony,imx335";
		reg = <0x1a>;
		clocks = <&clk_ext_camera>;
		avdd-supply = <&scmi_v3v3>;
		ovdd-supply = <&scmi_v3v3>;
		dvdd-supply = <&scmi_v3v3>;
		reset-gpios = <&pca9555_20 7 GPIO_ACTIVE_LOW>;
		status = "okay";

		port {
			imx335_ep: endpoint {
				remote-endpoint = <&csi_sink>;
				clock-lanes = <0>;
				data-lanes = <1 2>;
				link-frequencies = /bits/ 64 <594000000>;
			};
		};
	};	

	/* USER CODE END i2c1 */
};

&i2c2 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&i2c2_pins_mx>;
	pinctrl-1 = <&i2c2_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN i2c2 */
/*
	// gt911@5d {
	lvds_touchscreen@5d {
		compatible = "goodix,gt911";
		reg = <0x5d>;
		// reg = <0x14>;
		pinctrl-0 = <&pinctrl_lvds_touchscreen>;			
		interrupt-parent = <&gpiob>;
		interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
		irq-gpios = <&gpiob 6 GPIO_ACTIVE_HIGH>;	//the driver uses this line to set the i2c address during initialization
		reset-gpios = <&pca9555_20 6 GPIO_ACTIVE_LOW>;
		status = "okay";
	};	
*/
	/* eeprom on display */
	eeprom@50 {
		compatible = "atmel,24c02";
		reg = <0x50>;
		pagesize = <16>;		
		status = "okay";
	};

	max25221: max25221@21 {
		compatible = "maxim,max25221";
		reg = <0x21>;
		lcd-supply = <&reg_lvds_vdd_00314>;
		status = "okay";

		regulators {
			DISPLAY_reg: DISPLAY {
				regulator-name = "DISPLAY";
			};
		};
	};

	touchscreen@41 {
		compatible = "ilitek,ili251x";
		reg = <0x41>;
		pinctrl-names = "default";
		pinctrl-0 =<&pinctrl_lvds_touchscreen>;
		interrupt-parent = <&gpiob>;
		interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
		reset-gpios = <&pca9555_20 6 GPIO_ACTIVE_LOW>;
		// touchscreen-size-x = <1280>;
		// touchscreen-size-y = <800>;
	};
/* 
	dsi_touchscreen@41 {
		compatible = "ilitek,ili2520";
		reg = <0x41>;

		pinctrl-0 = <&pinctrl_dsi_touchscreen>;
		reset-gpios = <&pca9555_20 4 GPIO_ACTIVE_LOW>;
		interrupt-parent = <&gpiob>;
		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
		touchscreen-swapped-x-y;
		touchscreen-inverted-x;
		wakeup-source;
	};
*/
	/* USER CODE END i2c2 */
};

&i2c4 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&i2c4_pins_mx>;
	pinctrl-1 = <&i2c4_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN i2c4 */
	/* USER CODE END i2c4 */
};

&i2c6 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&i2c6_pins_mx>;
	pinctrl-1 = <&i2c6_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN i2c6 */
	/* USER CODE END i2c6 */
};

&ipcc1 {
	status = "okay";

	/* USER CODE BEGIN ipcc1 */
	/* USER CODE END ipcc1 */
};

&lpuart1 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&lpuart1_pins_z_mx>;
	pinctrl-1 = <&lpuart1_sleep_pins_z_mx>;
	status = "okay";

	/* USER CODE BEGIN lpuart1 */
	/delete-property/dmas;
	/delete-property/dma-names;
	uart-has-rtscts;
	bluetooth {
 		compatibility = "nxp,88w8987-bt";
 		fw-init-baudrate = <3000000>;
 	};
	/* USER CODE END lpuart1 */
};

&ltdc {
	status = "okay";

	/* USER CODE BEGIN ltdc */
	default-on;
	rotation-memory = <&ltdc_sec_rotation>;

	port {
		#address-cells = <1>;
		#size-cells = <0>;

		ltdc_ep0_out: endpoint@0 {
			reg = <0>;
			remote-endpoint = <&dsi_in>;
		};

		ltdc_ep1_out: endpoint@1 {
			reg = <1>;
			remote-endpoint = <&lvds_in>;
		};

	};
	/* USER CODE END ltdc */
};

&lvds {
	status = "okay";

	/* USER CODE BEGIN lvds */
	
	default-on;
	vdd-supply =  <&scmi_vddcore>;
	vdda18-supply = <&scmi_v1v8>;

	ports {
		#address-cells = <1>;
		#size-cells = <0>;

		port@0 {
			reg = <0>;
			lvds_in: endpoint {
				remote-endpoint = <&ltdc_ep1_out>;
			};
		};

		port@1 {
			reg = <1>;
			lvds_out0: endpoint {
				remote-endpoint = <&panel_lvds_in>;
			};
		};
	};	

	/* USER CODE END lvds */
};

&m33_rproc {
	status = "okay";

	/*Restriction: "memory-region" property is not managed - please to use User-Section if needed*/
	mboxes = <&ipcc1 0x100>, <&ipcc1 0x101>, <&ipcc1 2>;
	mbox-names = "vq0", "vq1", "shutdown";

	/* USER CODE BEGIN m33_rproc */
	/* USER CODE END m33_rproc */
};

&pcie_rc {
	status = "okay";

	/* USER CODE BEGIN pcie_rc */
	power-supply = <&reg_pcie_pwren>;
	reset-gpios = <&gpioa 12 GPIO_ACTIVE_LOW>;
	wakeup-source;
	wake-gpios = <&gpioh 9 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;	
	/* USER CODE END pcie_rc */
};

&sdmmc1 {
	pinctrl-names = "default", "opendrain", "sleep";
	pinctrl-0 = <&sdmmc1_pins_mx>;
	pinctrl-1 = <&sdmmc1_opendrain_pins_mx>;
	pinctrl-2 = <&sdmmc1_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN sdmmc1 */
	cd-gpios = <&gpiod 9 (GPIO_ACTIVE_LOW)>;
	disable-wp;
	st,neg-edge;
	bus-width = <4>;
	vmmc-supply = <&usd_pwron>;
	vqmmc-supply = <&scmi_vddio1>;
	sd-uhs-sdr12;
	sd-uhs-sdr25;
	sd-uhs-sdr50;
	sd-uhs-ddr50;
	sd-uhs-sdr104;
	/* USER CODE END sdmmc1 */
};

&sdmmc2 {
	pinctrl-names = "default", "opendrain", "sleep";
	pinctrl-0 = <&sdmmc2_pins_mx>;
	pinctrl-1 = <&sdmmc2_opendrain_pins_mx>;
	pinctrl-2 = <&sdmmc2_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN sdmmc2 */
	non-removable;
	no-sd;
	no-sdio;
	st,neg-edge;
	bus-width = <8>;
	vmmc-supply = <&scmi_vdd_emmc>;
	vqmmc-supply = <&scmi_vddio2>;
	mmc-ddr-1_8v;
	mmc-hs200-1_8v;
	/* USER CODE END sdmmc2 */
};

&sdmmc3 {
	pinctrl-names = "default", "opendrain", "sleep";
	pinctrl-0 = <&sdmmc3_pins_mx>;
	pinctrl-1 = <&sdmmc3_opendrain_pins_mx>;
	pinctrl-2 = <&sdmmc3_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN sdmmc3 */
	non-removable;
	st,neg-edge;
	bus-width = <4>;
	vmmc-supply = <&reg_sdmmc3_vmmc>;
	cap-power-off-card;
	keep-power-in-suspend;

	#address-cells = <1>;
	#size-cells = <0>;

	wifi_wake_host {
		compatible = "nxp,wifi-wake-host";
		interrupt-parent = <&gpiod>;
		interrupts = <8 IRQ_TYPE_LEVEL_LOW>;
		interrupt-names = "host-wake";
	};
	/* USER CODE END sdmmc3 */
};

&spi4 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&spi4_pins_mx>;
	pinctrl-1 = <&spi4_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN spi4 */
	/* USER CODE END spi4 */
};

&timers10 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&tim10_pwm_pins_mx>;
	pinctrl-1 = <&tim10_pwm_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN timers10 */
	/* USER CODE END timers10 */
};

&uart5 {
	pinctrl-names = "default", "idle", "sleep";
	pinctrl-0 = <&uart5_pins_mx>;
	pinctrl-1 = <&uart5_idle_pins_mx>;
	pinctrl-2 = <&uart5_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN uart5 */
	/* USER CODE END uart5 */
};

&uart7 {
	pinctrl-names = "default", "idle", "sleep";
	pinctrl-0 = <&uart7_pins_mx>;
	pinctrl-1 = <&uart7_idle_pins_mx>;
	pinctrl-2 = <&uart7_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN uart7 */
	/* USER CODE END uart7 */
};

&usart2 {
	pinctrl-names = "default", "idle", "sleep";
	pinctrl-0 = <&usart2_pins_mx>;
	pinctrl-1 = <&usart2_idle_pins_mx>;
	pinctrl-2 = <&usart2_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN usart2 */
	/* USER CODE END usart2 */
};

&usart3 {
	pinctrl-names = "default", "idle", "sleep";
	pinctrl-0 = <&usart3_pins_mx>;
	pinctrl-1 = <&usart3_idle_pins_mx>;
	pinctrl-2 = <&usart3_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN usart3 */
	/* USER CODE END usart3 */
};

&usb2_phy1 {
	status = "okay";

	/* USER CODE BEGIN usb2_phy1 */
	vdd33-supply = <&scmi_vdd3v3_usb>;
	/* USER CODE END usb2_phy1 */
};

&usb2_phy2 {
	status = "okay";

	/* USER CODE BEGIN usb2_phy2 */
	vdd33-supply = <&scmi_vdd3v3_usb>;
	/* USER CODE END usb2_phy2 */
};

&usb3dr {
	status = "okay";

	/* USER CODE BEGIN usb3dr */
	dwc3: usb@48300000 {
		maximum-speed 	= "high-speed";
		usb-role-switch;
		port {
			dwc3_ep: endpoint {
				remote-endpoint = <&typec_a_ep>;
			};
		};
	};	
	/* USER CODE END usb3dr */
};

&usbh {
	status = "okay";

	/* USER CODE BEGIN usbh */
	/* USER CODE END usbh */
};

&vdec {
	status = "okay";

	/* USER CODE BEGIN vdec */
	/* USER CODE END vdec */
};

&venc {
	status = "okay";

	/* USER CODE BEGIN venc */
	/* USER CODE END venc */
};

/* USER CODE BEGIN addons */
/ {
	model = "Cargt STM32MP257F OSM SOM 00395 (Linux)";

	
	panel_lvds_backlight: panel-lvds-backlight {
		compatible = "pwm-backlight";
		pwms = <&pwm10 0 1000000 0>;
		brightness-levels = <0 100>;
		num-interpolated-steps = <100>;
		default-brightness-level = <80>;
		power-supply = <&scmi_v3v3>;
		status = "okay";
	};

/*
	panel_lvds_backlight: panel-lvds-backlight {
		compatible = "gpio-backlight";
		gpios = <&gpiob 9 GPIO_ACTIVE_HIGH>;
		default-on;
		default-brightness-level = <1>;
		status = "okay";
	};
*/
/*
	panel_dsi_backlight: panel-dsi-backlight {
		compatible = "pwm-backlight";
		pwms = <&pwm12 1 1000000 0>;
		brightness-levels = <0 16 22 30 40 55 75 102 138 188 255>;
		default-brightness-level = <10>;
		power-supply = <&scmi_v3v3>;
		status = "okay";
	};

	panel_dsi_backlight: panel-dsi-backlight {
		compatible = "gpio-backlight";
		gpios = <&gpiof 8 GPIO_ACTIVE_HIGH>;
		default-on;
		default-brightness-level = <1>;
		status = "okay";
	};
*/
/*
	reg_lvds_vdd: regulator-lvds-vdd {
		compatible = "regulator-fixed";
		regulator-name = "lvds_vdd";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		gpio = <&pca9555_20 5 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		status = "disalbed";
	};	
*/
	reg_lvds_i2c_switch: regulator-lvds-i2c-switch {
		compatible = "regulator-fixed";
		regulator-name = "lvds_i2c_sw";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		gpio = <&pca9555_20 15 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		regulator-always-on;
		status = "okay";
	};	

	reg_lvds_vdd_00314: regulator-lvds-vdd {
		compatible = "regulator-fixed";
		regulator-name = "lvds_vdd";
		regulator-min-microvolt = <3300000>; // 00314 will boost 1.8V output to 3.3V 
		regulator-max-microvolt = <3300000>;
		gpio = <&pca9555_20 5 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		regulator-always-on;
		vin-supply = <&reg_lvds_i2c_switch>;
		status = "okay";
	};	

	reg_pcie_pwren: regulator-pcie-pwren {
		compatible = "regulator-fixed";
		regulator-name = "pcie-pwren";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		gpio = <&pca9555_20 9 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		regulator-always-on;
		status = "okay";
	};	

/*
	panel_lvds: panel-lvds {	
		compatible = "globaltech,gt_GLT0701024600IS2";
		backlight = <&panel_lvds_backlight>;
		power-supply = <&reg_lvds_vdd>;

		status = "okay";

		port {
			panel_lvds_in: endpoint {
				remote-endpoint = <&lvds_out0>;
			};
		};
	};
*/
	panel_lvds: panel-lvds {	
		compatible = "boe,ev121wxm-n10-1850";
		backlight = <&panel_lvds_backlight>;		
		power-supply = <&DISPLAY_reg>;

		port {
			panel_lvds_in: endpoint {
				remote-endpoint = <&lvds_out0>;
			};
		};
	};
};

&ipcc1 {
	status = "okay";
};

&ipcc2 {
	status = "okay";
};

&ahbsr {
	mbox_client: mailbox-client@1 {
		compatible = "mbox-cdev";
		reg = <1 0>;
		memory-region =  <&ipc_shmem_2>;
		mboxes = <&ipcc2 0>;
		mbox-names = "rx-tx";
		status = "okay";
	};
};

&arm_wdt {
	timeout-sec = <32>;
	status = "okay";
};

&scmi_regu {
	scmi_vddio1: regulator@0 {
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <3300000>;
	};
	scmi_vddio2: regulator@1 {
		reg = <VOLTD_SCMI_VDDIO2>;
		regulator-name = "vddio2";
	};
	scmi_vddio3: regulator@2 {
		reg = <VOLTD_SCMI_VDDIO3>;
		regulator-name = "vddio3";
	};
	scmi_vddio4: regulator@3 {
		reg = <VOLTD_SCMI_VDDIO4>;
		regulator-name = "vddio4";
	};
	scmi_vdd33ucpd: regulator@5 {
		reg = <VOLTD_SCMI_UCPD>;
		regulator-name = "vdd33ucpd";
	};
	scmi_vdda18adc: regulator@7 {
		reg = <VOLTD_SCMI_ADC>;
		regulator-name = "vdda18adc";
	};
	scmi_vddcore: regulator@11  {
		reg = <VOLTD_SCMI_STPMIC2_BUCK2>;
		regulator-name = "vddcore";
	};
	scmi_vddio1v8: regulator@12  {
		reg = <VOLTD_SCMI_STPMIC2_BUCK4>;
		regulator-name = "vddio_1v8";
	};
	scmi_v1v8: regulator@14  {
		reg = <VOLTD_SCMI_STPMIC2_BUCK5>;
		regulator-name = "v1v8";
	};
	scmi_v3v3: regulator@16 {
		reg = <VOLTD_SCMI_STPMIC2_BUCK7>;
		regulator-name = "v3v3";
	};
	scmi_vdd_emmc: regulator@18 {
		reg = <VOLTD_SCMI_STPMIC2_LDO2>;
		regulator-name = "vdd_emmc";
	};
	scmi_vdd3v3_usb: regulator@20 {
		reg = <VOLTD_SCMI_STPMIC2_LDO4>;
		regulator-name = "vdd3v3_usb";
	};
};


&timers10 {
	/delete-property/pinctrl-names;
	/delete-property/pinctrl-0;
	/delete-property/pinctrl-1;
	/delete-property/dmas;
	/delete-property/dma-names;
	status = "okay";

	pwm10: pwm {
		pinctrl-names = "default", "sleep";
		pinctrl-0 = <&tim10_pwm_pins_mx>;
		pinctrl-1 = <&tim10_pwm_sleep_pins_mx>;
		status = "okay";
	};	
};


// &timers12 {
// 	/delete-property/pinctrl-names;
// 	/delete-property/pinctrl-0;
// 	/delete-property/pinctrl-1;
// 	/delete-property/dmas;
// 	/delete-property/dma-names;	
// 	status = "disabled";

// 	pwm12: pwm {
// 		pinctrl-names = "default", "sleep";
// 		pinctrl-0 = <&tim12_pwm_pins_mx>;
// 		pinctrl-1 = <&tim12_pwm_sleep_pins_mx>;
// 		status = "disabled";
// 	};		
// };


&dsi {
	status = "disabled";
};
/* USER CODE END addons */

